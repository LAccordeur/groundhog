# Groundhog
There are three parts in Groundhog project.
- **groundhog-host**: This directory contains the code on the host side including the self-contained and segment-based library, a simple file system, and codes used in the experiments.
- **myssd_sdk**: This directory contains the FTL code running inside the CSD. We extend the FTL to support the offloading procedure and the computation of spatio-temporal queries.
- **spdk**: This directory is forked from spdk library. We extend the NVMe to support the ISC command.

### groundhog-host
- The code of the format library: [`groundhog-host/src/groundhog/traj_block_format.c`](https://github.com/LAccordeur/groundhog/blob/main/groundhog-host/src/groundhog/traj_block_format.c).
- The experiment codes: [`groundhog-host/src/groundhog/exp/exp_native_host_and_device.c`](https://github.com/LAccordeur/groundhog/tree/main/groundhog-host/src/groundhog/exp/exp_native_host_and_device.c).

## myssd_sdk
The code of ISC query engine is in the directory [`myssd_sdk/src/groundhog-src`](https://github.com/LAccordeur/groundhog/tree/main/myssd_sdk/src/groundhog-src).

We extend the FTL to support the offloading:
  - Fetch the ISC descriptors from the host memory: [`process_io_request`](https://github.com/LAccordeur/groundhog/blob/main/myssd_sdk/src/ftl/ftl.c#L232)
  - Supporting the ISC cmds: [`handle_cached_exe_multi`](https://github.com/LAccordeur/groundhog/blob/main/myssd_sdk/src/ftl/data_cache.c#L1125).
  - Return the reduced result size: [`transfer_prp_data`](https://github.com/LAccordeur/groundhog/blob/main/myssd_sdk/src/hostif/nvme.c#L106).

## spdk
We extend to following code files to support ISC commands:
- `include/spdk/nvme.h`
- `include/spdk/nvme_spec.h`
- `lib/nvme/nvme_ns_cmd.c`

An added function example can be found [`spdk_nvme_ns_cmd_exe_multi`](https://github.com/LAccordeur/groundhog/blob/main/spdk/lib/nvme/nvme_ns_cmd.c#L847).

## How to run the whole project

### Hardware requirement

A customed computational storage device (CSD) based on Xilinx Zynq UltraScale+ MPSoc development board.
We use Vivado 2020.2 and Xilinx Vitis 2020.2.0 as our development plarform.
The CSD is installed on a host machine via PCIe.

### Step 1: Configure and run the CSD
This step uses Vitis to deploy the code in the **myssd_sdk**. 

1. In ~scripts/create_projects.tcl~, change the line ~set XSA_FILE ...~ to the path of the XSA file generated by Vivado. We provided a XSA file (named as ~system_wrapper.xsa~) in the root of this project.

2. From Vitis's XSCT console, run
   #+BEGIN_SRC shell
   %source <project root>/scripts/create_projects.tcl
   #+END_SRC
   This will generate the platform project as well as three application projects for the FTL, the flash interface layer and the ECC engine, respectively.

3. From the project root, run
   #+BEGIN_SRC shell
   ./populate_workspace.sh <Vitis workspace folder>
   #+END_SRC
    This will set up links from the project folders in the Vitis workspace to the source directories.

4. Build the ~nvme_ftl_system~ project in Vitis.

5. Right click the ~nvme_ftl_system~ project in Vitis, "Run As" -> "Run configurations...", double click "System Project Debug" to add new a run configuration ~SystemDebugger_nvme_ftl_system~. Under the "Target Setup" tab, deselect "Use FSBL flow for initialization" and select "Reset APU", "Reset RPU", "Enable RPU Split Mode", "Run psu_init" and "PL Powerup". Press "Run" to run the project.

After the above steps, the CSD is run as an NVMe device on a host machine. Using the ~lspci~, we can get the following in the teminal.
   #+BEGIN_SRC shell
   %02:00.0 Non-Volatile memory controller: Xilinx Corporation Device 9038
   #+END_SRC

### Step 2: Access the CSD

In the host machine, we deploy the code from the **spdk** and **groundhog-host** to access the CSD.

1. Compile the SPDK code 
~~~{.sh}
cd spdk
./configure
make
~~~

2. Before running an SPDK application (e.g., **groundhog-host** in our project), some hugepages must be allocated and any NVMe and I/OAT devices must be unbound from the native kernel drivers.
SPDK includes a script to automate this process on both Linux and FreeBSD.
This script should be run as root.

~~~{.sh}
sudo scripts/setup.sh
~~~

3. Compile and run our **groundhog-host** application

~~~{.sh}
cd groundhog-host
mkdir build & cd build
cmake ..
make
~~~

Then the executable binary codes are in the build directory.



